### 问题描述
给定一个范围［l，r］，求出这个范围内的满足要求的数字的个数。要求是：
这些数字不能包含某个数字n。例如，不能包含数字”1”时，那么数字22、32、4都符合要求，数字2314，1233不符合要求。
### 解答要求
时间限制：1000ms, 内存限制：100MB
### 输入
输入一行l, r, n, 三个整数(1 <= l < r <= 1000000000, 0 <= n < 10)
表示范围为[l, r]，不能包含数字n。

### 输出
输出一行一个整数，表示符合要求的数字的个数。

### 样例
- 输入
```
1 20 2
```
- 输出
```
17
```

### 错误的解答思路
乍一看，好像很简单，直接循环从l遍历到r，循环中将整型转换成字符型再判断字符串中是否包含n就解决了。于是顺手就抛出了如下JS代码。
```JS
process.stdin.resume();
process.stdin.setEncoding('utf-8');
let input = '';
process.stdin.on('data', (data) => {
  input += data;
});
process.stdin.on('end', () => {
    let inputArray = input.split('\n')[0].split(' ');
    let [l, r, n]= inputArray;
    let sum = 0;
    l = parseInt(l);
    r = parseInt(r);
    for(let i = l; i <= r; i++){
        if(i.toString().indexOf(n) == -1){
            sum++;
        }
    }
    console.log(sum);
  process.exit();
});
```
但是一提交就发现不对劲了，数一大就运行内存限制的错误了，其实运行时间也超时了。

### 正确的解答思路一:统计法
- 我们先计算[0, r]之间符合要求的个数，并假设r的各位只有9
- 当n>0时，得出计算公式为pow(9, i)

| 数字范围 | 满足要求的个数 |
| --- | --- |
| 0-9	| 9 = 9^1 |
| 0-99	| 81 = 9^2 |
| 0-999	| 729 = 9^3 |
| 0-9999	| 6561 = 9^4 |

- 当n=0时，得出计算公式为pow(9, i) + f(n-1)

|数字范围	| 满足要求的个数|
| --- | --- |
| 0-9	| 9 = 9^1 |
| 0-99	| 90 = 9^2 + 9^1 |
| 0-999	| 819 = 9^3 + 9^2 + 9^1 |
| 0-9999	| 7380 = 9^4 + 9^3 + 9^2 + 9^1 |

- 得到这两个公式之后
- 
